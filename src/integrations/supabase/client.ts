// This file is automatically generated. Do not edit it directly.
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Check if Supabase environment variables are properly configured (non-empty strings)
const isSupabaseConfigured = Boolean(
  SUPABASE_URL?.trim() && SUPABASE_PUBLISHABLE_KEY?.trim()
);

// Create a mock client that returns empty results when Supabase is not configured
const createMockClient = (): SupabaseClient<Database> => {
  // PostgrestError-compatible error structure
  const mockError = {
    message: 'Supabase not configured',
    details: 'Environment variables VITE_SUPABASE_URL and VITE_SUPABASE_PUBLISHABLE_KEY are required',
    hint: 'Set up Supabase environment variables to enable database functionality',
    code: 'PGRST000',
  };

  const mockResponse = {
    data: null,
    error: mockError,
    count: null,
    status: 500,
    statusText: 'Supabase not configured',
  };

  // Create a thenable mock query builder for promise-like chaining
  const createMockQueryBuilder = () => {
    const builder = {
      select: () => createMockQueryBuilder(),
      insert: () => createMockQueryBuilder(),
      update: () => createMockQueryBuilder(),
      delete: () => createMockQueryBuilder(),
      eq: () => createMockQueryBuilder(),
      neq: () => createMockQueryBuilder(),
      order: () => createMockQueryBuilder(),
      limit: () => createMockQueryBuilder(),
      range: () => createMockQueryBuilder(),
      single: () => Promise.resolve(mockResponse),
      maybeSingle: () => Promise.resolve(mockResponse),
      then: (
        onfulfilled?: (value: typeof mockResponse) => unknown,
        onrejected?: (reason: unknown) => unknown
      ) => Promise.resolve(mockResponse).then(onfulfilled, onrejected),
      catch: (onrejected?: (reason: unknown) => unknown) =>
        Promise.resolve(mockResponse).catch(onrejected),
    };
    return builder;
  };

  return {
    from: () => createMockQueryBuilder(),
    rpc: () => Promise.resolve(mockResponse),
    auth: {
      getSession: () => Promise.resolve({ data: { session: null }, error: null }),
      signOut: () => Promise.resolve({ error: null }),
      onAuthStateChange: () => ({ data: { subscription: { unsubscribe: () => {} } } }),
    },
    storage: {
      from: () => ({
        upload: () => Promise.resolve({ data: null, error: mockError }),
        download: () => Promise.resolve({ data: null, error: mockError }),
        getPublicUrl: () => ({ data: { publicUrl: '' } }),
      }),
    },
  } as unknown as SupabaseClient<Database>;
};

export const supabase: SupabaseClient<Database> = isSupabaseConfigured
  ? createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
      auth: {
        storage: localStorage,
        persistSession: true,
        autoRefreshToken: true,
      }
    })
  : createMockClient();

export { isSupabaseConfigured };